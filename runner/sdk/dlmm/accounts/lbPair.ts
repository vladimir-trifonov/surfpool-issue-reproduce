/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI32Decoder,
  getI32Encoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getProtocolFeeDecoder,
  getProtocolFeeEncoder,
  getRewardInfoDecoder,
  getRewardInfoEncoder,
  getStaticParametersDecoder,
  getStaticParametersEncoder,
  getVariableParametersDecoder,
  getVariableParametersEncoder,
  type ProtocolFee,
  type ProtocolFeeArgs,
  type RewardInfo,
  type RewardInfoArgs,
  type StaticParameters,
  type StaticParametersArgs,
  type VariableParameters,
  type VariableParametersArgs,
} from '../types';

export const LB_PAIR_DISCRIMINATOR = new Uint8Array([
  33, 11, 49, 98, 181, 101, 177, 13,
]);

export function getLbPairDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(LB_PAIR_DISCRIMINATOR);
}

export type LbPair = {
  discriminator: ReadonlyUint8Array;
  parameters: StaticParameters;
  vParameters: VariableParameters;
  bumpSeed: ReadonlyUint8Array;
  /** Bin step signer seed */
  binStepSeed: ReadonlyUint8Array;
  /** Type of the pair */
  pairType: number;
  /** Active bin id */
  activeId: number;
  /** Bin step. Represent the price increment / decrement. */
  binStep: number;
  /** Status of the pair. Check PairStatus enum. */
  status: number;
  /** Require base factor seed */
  requireBaseFactorSeed: number;
  /** Base factor seed */
  baseFactorSeed: ReadonlyUint8Array;
  /** Activation type */
  activationType: number;
  /** Allow pool creator to enable/disable pool with restricted validation. Only applicable for customizable permissionless pair type. */
  creatorPoolOnOffControl: number;
  /** Token X mint */
  tokenXMint: Address;
  /** Token Y mint */
  tokenYMint: Address;
  /** LB token X vault */
  reserveX: Address;
  /** LB token Y vault */
  reserveY: Address;
  /** Uncollected protocol fee */
  protocolFee: ProtocolFee;
  /** _padding_1, previous Fee owner, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding1: ReadonlyUint8Array;
  /** Farming reward information */
  rewardInfos: Array<RewardInfo>;
  /** Oracle pubkey */
  oracle: Address;
  /** Packed initialized bin array state */
  binArrayBitmap: Array<bigint>;
  /** Last time the pool fee parameter was updated */
  lastUpdatedAt: bigint;
  /** _padding_2, previous whitelisted_wallet, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding2: ReadonlyUint8Array;
  /** Address allowed to swap when the current point is greater than or equal to the pre-activation point. The pre-activation point is calculated as `activation_point - pre_activation_duration`. */
  preActivationSwapAddress: Address;
  /** Base keypair. Only required for permission pair */
  baseKey: Address;
  /** Time point to enable the pair. Only applicable for permission pair. */
  activationPoint: bigint;
  /** Duration before activation activation_point. Used to calculate pre-activation time point for pre_activation_swap_address */
  preActivationDuration: bigint;
  /** _padding 3 is reclaimed free space from swap_cap_deactivate_point and swap_cap_amount before, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding3: ReadonlyUint8Array;
  /** _padding_4, previous lock_duration, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding4: bigint;
  /** Pool creator */
  creator: Address;
  /** token_mint_x_program_flag */
  tokenMintXProgramFlag: number;
  /** token_mint_y_program_flag */
  tokenMintYProgramFlag: number;
  /** Reserved space for future use */
  reserved: ReadonlyUint8Array;
};

export type LbPairArgs = {
  parameters: StaticParametersArgs;
  vParameters: VariableParametersArgs;
  bumpSeed: ReadonlyUint8Array;
  /** Bin step signer seed */
  binStepSeed: ReadonlyUint8Array;
  /** Type of the pair */
  pairType: number;
  /** Active bin id */
  activeId: number;
  /** Bin step. Represent the price increment / decrement. */
  binStep: number;
  /** Status of the pair. Check PairStatus enum. */
  status: number;
  /** Require base factor seed */
  requireBaseFactorSeed: number;
  /** Base factor seed */
  baseFactorSeed: ReadonlyUint8Array;
  /** Activation type */
  activationType: number;
  /** Allow pool creator to enable/disable pool with restricted validation. Only applicable for customizable permissionless pair type. */
  creatorPoolOnOffControl: number;
  /** Token X mint */
  tokenXMint: Address;
  /** Token Y mint */
  tokenYMint: Address;
  /** LB token X vault */
  reserveX: Address;
  /** LB token Y vault */
  reserveY: Address;
  /** Uncollected protocol fee */
  protocolFee: ProtocolFeeArgs;
  /** _padding_1, previous Fee owner, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding1: ReadonlyUint8Array;
  /** Farming reward information */
  rewardInfos: Array<RewardInfoArgs>;
  /** Oracle pubkey */
  oracle: Address;
  /** Packed initialized bin array state */
  binArrayBitmap: Array<number | bigint>;
  /** Last time the pool fee parameter was updated */
  lastUpdatedAt: number | bigint;
  /** _padding_2, previous whitelisted_wallet, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding2: ReadonlyUint8Array;
  /** Address allowed to swap when the current point is greater than or equal to the pre-activation point. The pre-activation point is calculated as `activation_point - pre_activation_duration`. */
  preActivationSwapAddress: Address;
  /** Base keypair. Only required for permission pair */
  baseKey: Address;
  /** Time point to enable the pair. Only applicable for permission pair. */
  activationPoint: number | bigint;
  /** Duration before activation activation_point. Used to calculate pre-activation time point for pre_activation_swap_address */
  preActivationDuration: number | bigint;
  /** _padding 3 is reclaimed free space from swap_cap_deactivate_point and swap_cap_amount before, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding3: ReadonlyUint8Array;
  /** _padding_4, previous lock_duration, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
  padding4: number | bigint;
  /** Pool creator */
  creator: Address;
  /** token_mint_x_program_flag */
  tokenMintXProgramFlag: number;
  /** token_mint_y_program_flag */
  tokenMintYProgramFlag: number;
  /** Reserved space for future use */
  reserved: ReadonlyUint8Array;
};

export function getLbPairEncoder(): FixedSizeEncoder<LbPairArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['parameters', getStaticParametersEncoder()],
      ['vParameters', getVariableParametersEncoder()],
      ['bumpSeed', fixEncoderSize(getBytesEncoder(), 1)],
      ['binStepSeed', fixEncoderSize(getBytesEncoder(), 2)],
      ['pairType', getU8Encoder()],
      ['activeId', getI32Encoder()],
      ['binStep', getU16Encoder()],
      ['status', getU8Encoder()],
      ['requireBaseFactorSeed', getU8Encoder()],
      ['baseFactorSeed', fixEncoderSize(getBytesEncoder(), 2)],
      ['activationType', getU8Encoder()],
      ['creatorPoolOnOffControl', getU8Encoder()],
      ['tokenXMint', getAddressEncoder()],
      ['tokenYMint', getAddressEncoder()],
      ['reserveX', getAddressEncoder()],
      ['reserveY', getAddressEncoder()],
      ['protocolFee', getProtocolFeeEncoder()],
      ['padding1', fixEncoderSize(getBytesEncoder(), 32)],
      ['rewardInfos', getArrayEncoder(getRewardInfoEncoder(), { size: 2 })],
      ['oracle', getAddressEncoder()],
      ['binArrayBitmap', getArrayEncoder(getU64Encoder(), { size: 16 })],
      ['lastUpdatedAt', getI64Encoder()],
      ['padding2', fixEncoderSize(getBytesEncoder(), 32)],
      ['preActivationSwapAddress', getAddressEncoder()],
      ['baseKey', getAddressEncoder()],
      ['activationPoint', getU64Encoder()],
      ['preActivationDuration', getU64Encoder()],
      ['padding3', fixEncoderSize(getBytesEncoder(), 8)],
      ['padding4', getU64Encoder()],
      ['creator', getAddressEncoder()],
      ['tokenMintXProgramFlag', getU8Encoder()],
      ['tokenMintYProgramFlag', getU8Encoder()],
      ['reserved', fixEncoderSize(getBytesEncoder(), 22)],
    ]),
    (value) => ({ ...value, discriminator: LB_PAIR_DISCRIMINATOR })
  );
}

export function getLbPairDecoder(): FixedSizeDecoder<LbPair> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['parameters', getStaticParametersDecoder()],
    ['vParameters', getVariableParametersDecoder()],
    ['bumpSeed', fixDecoderSize(getBytesDecoder(), 1)],
    ['binStepSeed', fixDecoderSize(getBytesDecoder(), 2)],
    ['pairType', getU8Decoder()],
    ['activeId', getI32Decoder()],
    ['binStep', getU16Decoder()],
    ['status', getU8Decoder()],
    ['requireBaseFactorSeed', getU8Decoder()],
    ['baseFactorSeed', fixDecoderSize(getBytesDecoder(), 2)],
    ['activationType', getU8Decoder()],
    ['creatorPoolOnOffControl', getU8Decoder()],
    ['tokenXMint', getAddressDecoder()],
    ['tokenYMint', getAddressDecoder()],
    ['reserveX', getAddressDecoder()],
    ['reserveY', getAddressDecoder()],
    ['protocolFee', getProtocolFeeDecoder()],
    ['padding1', fixDecoderSize(getBytesDecoder(), 32)],
    ['rewardInfos', getArrayDecoder(getRewardInfoDecoder(), { size: 2 })],
    ['oracle', getAddressDecoder()],
    ['binArrayBitmap', getArrayDecoder(getU64Decoder(), { size: 16 })],
    ['lastUpdatedAt', getI64Decoder()],
    ['padding2', fixDecoderSize(getBytesDecoder(), 32)],
    ['preActivationSwapAddress', getAddressDecoder()],
    ['baseKey', getAddressDecoder()],
    ['activationPoint', getU64Decoder()],
    ['preActivationDuration', getU64Decoder()],
    ['padding3', fixDecoderSize(getBytesDecoder(), 8)],
    ['padding4', getU64Decoder()],
    ['creator', getAddressDecoder()],
    ['tokenMintXProgramFlag', getU8Decoder()],
    ['tokenMintYProgramFlag', getU8Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 22)],
  ]);
}

export function getLbPairCodec(): FixedSizeCodec<LbPairArgs, LbPair> {
  return combineCodec(getLbPairEncoder(), getLbPairDecoder());
}

export function decodeLbPair<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<LbPair, TAddress>;
export function decodeLbPair<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<LbPair, TAddress>;
export function decodeLbPair<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<LbPair, TAddress> | MaybeAccount<LbPair, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getLbPairDecoder()
  );
}

export async function fetchLbPair<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<LbPair, TAddress>> {
  const maybeAccount = await fetchMaybeLbPair(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeLbPair<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<LbPair, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeLbPair(maybeAccount);
}

export async function fetchAllLbPair(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<LbPair>[]> {
  const maybeAccounts = await fetchAllMaybeLbPair(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeLbPair(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<LbPair>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeLbPair(maybeAccount));
}

export function getLbPairSize(): number {
  return 904;
}
