/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/kit';
import { RAYDIUM_CP_SWAP_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const INITIALIZE_DISCRIMINATOR = new Uint8Array([
  175, 175, 109, 31, 13, 152, 155, 237,
]);

export function getInitializeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_DISCRIMINATOR);
}

export type InitializeInstruction<
  TProgram extends string = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
  TAccountCreator extends string | AccountMeta<string> = string,
  TAccountAmmConfig extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountPoolState extends string | AccountMeta<string> = string,
  TAccountToken0Mint extends string | AccountMeta<string> = string,
  TAccountToken1Mint extends string | AccountMeta<string> = string,
  TAccountLpMint extends string | AccountMeta<string> = string,
  TAccountCreatorToken0 extends string | AccountMeta<string> = string,
  TAccountCreatorToken1 extends string | AccountMeta<string> = string,
  TAccountCreatorLpToken extends string | AccountMeta<string> = string,
  TAccountToken0Vault extends string | AccountMeta<string> = string,
  TAccountToken1Vault extends string | AccountMeta<string> = string,
  TAccountCreatePoolFee extends string | AccountMeta<string> = string,
  TAccountObservationState extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountToken0Program extends string | AccountMeta<string> = string,
  TAccountToken1Program extends string | AccountMeta<string> = string,
  TAccountAssociatedTokenProgram extends string | AccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | AccountMeta<string> = '11111111111111111111111111111111',
  TAccountRent extends
    | string
    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountCreator extends string
        ? WritableSignerAccount<TAccountCreator> &
            AccountSignerMeta<TAccountCreator>
        : TAccountCreator,
      TAccountAmmConfig extends string
        ? ReadonlyAccount<TAccountAmmConfig>
        : TAccountAmmConfig,
      TAccountAuthority extends string
        ? ReadonlyAccount<TAccountAuthority>
        : TAccountAuthority,
      TAccountPoolState extends string
        ? WritableAccount<TAccountPoolState>
        : TAccountPoolState,
      TAccountToken0Mint extends string
        ? ReadonlyAccount<TAccountToken0Mint>
        : TAccountToken0Mint,
      TAccountToken1Mint extends string
        ? ReadonlyAccount<TAccountToken1Mint>
        : TAccountToken1Mint,
      TAccountLpMint extends string
        ? WritableAccount<TAccountLpMint>
        : TAccountLpMint,
      TAccountCreatorToken0 extends string
        ? WritableAccount<TAccountCreatorToken0>
        : TAccountCreatorToken0,
      TAccountCreatorToken1 extends string
        ? WritableAccount<TAccountCreatorToken1>
        : TAccountCreatorToken1,
      TAccountCreatorLpToken extends string
        ? WritableAccount<TAccountCreatorLpToken>
        : TAccountCreatorLpToken,
      TAccountToken0Vault extends string
        ? WritableAccount<TAccountToken0Vault>
        : TAccountToken0Vault,
      TAccountToken1Vault extends string
        ? WritableAccount<TAccountToken1Vault>
        : TAccountToken1Vault,
      TAccountCreatePoolFee extends string
        ? WritableAccount<TAccountCreatePoolFee>
        : TAccountCreatePoolFee,
      TAccountObservationState extends string
        ? WritableAccount<TAccountObservationState>
        : TAccountObservationState,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountToken0Program extends string
        ? ReadonlyAccount<TAccountToken0Program>
        : TAccountToken0Program,
      TAccountToken1Program extends string
        ? ReadonlyAccount<TAccountToken1Program>
        : TAccountToken1Program,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountRent extends string
        ? ReadonlyAccount<TAccountRent>
        : TAccountRent,
      ...TRemainingAccounts,
    ]
  >;

export type InitializeInstructionData = {
  discriminator: ReadonlyUint8Array;
  initAmount0: bigint;
  initAmount1: bigint;
  openTime: bigint;
};

export type InitializeInstructionDataArgs = {
  initAmount0: number | bigint;
  initAmount1: number | bigint;
  openTime: number | bigint;
};

export function getInitializeInstructionDataEncoder(): FixedSizeEncoder<InitializeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['initAmount0', getU64Encoder()],
      ['initAmount1', getU64Encoder()],
      ['openTime', getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_DISCRIMINATOR })
  );
}

export function getInitializeInstructionDataDecoder(): FixedSizeDecoder<InitializeInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['initAmount0', getU64Decoder()],
    ['initAmount1', getU64Decoder()],
    ['openTime', getU64Decoder()],
  ]);
}

export function getInitializeInstructionDataCodec(): FixedSizeCodec<
  InitializeInstructionDataArgs,
  InitializeInstructionData
> {
  return combineCodec(
    getInitializeInstructionDataEncoder(),
    getInitializeInstructionDataDecoder()
  );
}

export type InitializeInput<
  TAccountCreator extends string = string,
  TAccountAmmConfig extends string = string,
  TAccountAuthority extends string = string,
  TAccountPoolState extends string = string,
  TAccountToken0Mint extends string = string,
  TAccountToken1Mint extends string = string,
  TAccountLpMint extends string = string,
  TAccountCreatorToken0 extends string = string,
  TAccountCreatorToken1 extends string = string,
  TAccountCreatorLpToken extends string = string,
  TAccountToken0Vault extends string = string,
  TAccountToken1Vault extends string = string,
  TAccountCreatePoolFee extends string = string,
  TAccountObservationState extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountToken0Program extends string = string,
  TAccountToken1Program extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
> = {
  /** Address paying to create the pool. Can be anyone */
  creator: TransactionSigner<TAccountCreator>;
  /** Which config the pool belongs to. */
  ammConfig: Address<TAccountAmmConfig>;
  authority: Address<TAccountAuthority>;
  /** Initialize an account to store the pool state */
  poolState: Address<TAccountPoolState>;
  /** Token_0 mint, the key must smaller then token_1 mint. */
  token0Mint: Address<TAccountToken0Mint>;
  /** Token_1 mint, the key must grater then token_0 mint. */
  token1Mint: Address<TAccountToken1Mint>;
  /** pool lp mint */
  lpMint: Address<TAccountLpMint>;
  /** payer token0 account */
  creatorToken0: Address<TAccountCreatorToken0>;
  /** creator token1 account */
  creatorToken1: Address<TAccountCreatorToken1>;
  /** creator lp token account */
  creatorLpToken: Address<TAccountCreatorLpToken>;
  token0Vault: Address<TAccountToken0Vault>;
  token1Vault: Address<TAccountToken1Vault>;
  /** create pool fee account */
  createPoolFee: Address<TAccountCreatePoolFee>;
  /** an account to store oracle observations */
  observationState: Address<TAccountObservationState>;
  /** Program to create mint account and mint tokens */
  tokenProgram?: Address<TAccountTokenProgram>;
  /** Spl token program or token program 2022 */
  token0Program: Address<TAccountToken0Program>;
  /** Spl token program or token program 2022 */
  token1Program: Address<TAccountToken1Program>;
  /** Program to create an ATA for receiving position NFT */
  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;
  /** To create a new program account */
  systemProgram?: Address<TAccountSystemProgram>;
  /** Sysvar for program account */
  rent?: Address<TAccountRent>;
  initAmount0: InitializeInstructionDataArgs['initAmount0'];
  initAmount1: InitializeInstructionDataArgs['initAmount1'];
  openTime: InitializeInstructionDataArgs['openTime'];
};

export function getInitializeInstruction<
  TAccountCreator extends string,
  TAccountAmmConfig extends string,
  TAccountAuthority extends string,
  TAccountPoolState extends string,
  TAccountToken0Mint extends string,
  TAccountToken1Mint extends string,
  TAccountLpMint extends string,
  TAccountCreatorToken0 extends string,
  TAccountCreatorToken1 extends string,
  TAccountCreatorLpToken extends string,
  TAccountToken0Vault extends string,
  TAccountToken1Vault extends string,
  TAccountCreatePoolFee extends string,
  TAccountObservationState extends string,
  TAccountTokenProgram extends string,
  TAccountToken0Program extends string,
  TAccountToken1Program extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountRent extends string,
  TProgramAddress extends Address = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
>(
  input: InitializeInput<
    TAccountCreator,
    TAccountAmmConfig,
    TAccountAuthority,
    TAccountPoolState,
    TAccountToken0Mint,
    TAccountToken1Mint,
    TAccountLpMint,
    TAccountCreatorToken0,
    TAccountCreatorToken1,
    TAccountCreatorLpToken,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountCreatePoolFee,
    TAccountObservationState,
    TAccountTokenProgram,
    TAccountToken0Program,
    TAccountToken1Program,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram,
    TAccountRent
  >,
  config?: { programAddress?: TProgramAddress }
): InitializeInstruction<
  TProgramAddress,
  TAccountCreator,
  TAccountAmmConfig,
  TAccountAuthority,
  TAccountPoolState,
  TAccountToken0Mint,
  TAccountToken1Mint,
  TAccountLpMint,
  TAccountCreatorToken0,
  TAccountCreatorToken1,
  TAccountCreatorLpToken,
  TAccountToken0Vault,
  TAccountToken1Vault,
  TAccountCreatePoolFee,
  TAccountObservationState,
  TAccountTokenProgram,
  TAccountToken0Program,
  TAccountToken1Program,
  TAccountAssociatedTokenProgram,
  TAccountSystemProgram,
  TAccountRent
> {
  // Program address.
  const programAddress =
    config?.programAddress ?? RAYDIUM_CP_SWAP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    creator: { value: input.creator ?? null, isWritable: true },
    ammConfig: { value: input.ammConfig ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    poolState: { value: input.poolState ?? null, isWritable: true },
    token0Mint: { value: input.token0Mint ?? null, isWritable: false },
    token1Mint: { value: input.token1Mint ?? null, isWritable: false },
    lpMint: { value: input.lpMint ?? null, isWritable: true },
    creatorToken0: { value: input.creatorToken0 ?? null, isWritable: true },
    creatorToken1: { value: input.creatorToken1 ?? null, isWritable: true },
    creatorLpToken: { value: input.creatorLpToken ?? null, isWritable: true },
    token0Vault: { value: input.token0Vault ?? null, isWritable: true },
    token1Vault: { value: input.token1Vault ?? null, isWritable: true },
    createPoolFee: { value: input.createPoolFee ?? null, isWritable: true },
    observationState: {
      value: input.observationState ?? null,
      isWritable: true,
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    token0Program: { value: input.token0Program ?? null, isWritable: false },
    token1Program: { value: input.token1Program ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.rent.value) {
    accounts.rent.value =
      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.creator),
      getAccountMeta(accounts.ammConfig),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.poolState),
      getAccountMeta(accounts.token0Mint),
      getAccountMeta(accounts.token1Mint),
      getAccountMeta(accounts.lpMint),
      getAccountMeta(accounts.creatorToken0),
      getAccountMeta(accounts.creatorToken1),
      getAccountMeta(accounts.creatorLpToken),
      getAccountMeta(accounts.token0Vault),
      getAccountMeta(accounts.token1Vault),
      getAccountMeta(accounts.createPoolFee),
      getAccountMeta(accounts.observationState),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.token0Program),
      getAccountMeta(accounts.token1Program),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
    ],
    data: getInitializeInstructionDataEncoder().encode(
      args as InitializeInstructionDataArgs
    ),
    programAddress,
  } as InitializeInstruction<
    TProgramAddress,
    TAccountCreator,
    TAccountAmmConfig,
    TAccountAuthority,
    TAccountPoolState,
    TAccountToken0Mint,
    TAccountToken1Mint,
    TAccountLpMint,
    TAccountCreatorToken0,
    TAccountCreatorToken1,
    TAccountCreatorLpToken,
    TAccountToken0Vault,
    TAccountToken1Vault,
    TAccountCreatePoolFee,
    TAccountObservationState,
    TAccountTokenProgram,
    TAccountToken0Program,
    TAccountToken1Program,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram,
    TAccountRent
  >);
}

export type ParsedInitializeInstruction<
  TProgram extends string = typeof RAYDIUM_CP_SWAP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Address paying to create the pool. Can be anyone */
    creator: TAccountMetas[0];
    /** Which config the pool belongs to. */
    ammConfig: TAccountMetas[1];
    authority: TAccountMetas[2];
    /** Initialize an account to store the pool state */
    poolState: TAccountMetas[3];
    /** Token_0 mint, the key must smaller then token_1 mint. */
    token0Mint: TAccountMetas[4];
    /** Token_1 mint, the key must grater then token_0 mint. */
    token1Mint: TAccountMetas[5];
    /** pool lp mint */
    lpMint: TAccountMetas[6];
    /** payer token0 account */
    creatorToken0: TAccountMetas[7];
    /** creator token1 account */
    creatorToken1: TAccountMetas[8];
    /** creator lp token account */
    creatorLpToken: TAccountMetas[9];
    token0Vault: TAccountMetas[10];
    token1Vault: TAccountMetas[11];
    /** create pool fee account */
    createPoolFee: TAccountMetas[12];
    /** an account to store oracle observations */
    observationState: TAccountMetas[13];
    /** Program to create mint account and mint tokens */
    tokenProgram: TAccountMetas[14];
    /** Spl token program or token program 2022 */
    token0Program: TAccountMetas[15];
    /** Spl token program or token program 2022 */
    token1Program: TAccountMetas[16];
    /** Program to create an ATA for receiving position NFT */
    associatedTokenProgram: TAccountMetas[17];
    /** To create a new program account */
    systemProgram: TAccountMetas[18];
    /** Sysvar for program account */
    rent: TAccountMetas[19];
  };
  data: InitializeInstructionData;
};

export function parseInitializeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedInitializeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 20) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      creator: getNextAccount(),
      ammConfig: getNextAccount(),
      authority: getNextAccount(),
      poolState: getNextAccount(),
      token0Mint: getNextAccount(),
      token1Mint: getNextAccount(),
      lpMint: getNextAccount(),
      creatorToken0: getNextAccount(),
      creatorToken1: getNextAccount(),
      creatorLpToken: getNextAccount(),
      token0Vault: getNextAccount(),
      token1Vault: getNextAccount(),
      createPoolFee: getNextAccount(),
      observationState: getNextAccount(),
      tokenProgram: getNextAccount(),
      token0Program: getNextAccount(),
      token1Program: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
    },
    data: getInitializeInstructionDataDecoder().decode(instruction.data),
  };
}
