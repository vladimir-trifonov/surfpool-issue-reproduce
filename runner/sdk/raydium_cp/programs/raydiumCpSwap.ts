/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedCollectFundFeeInstruction,
  type ParsedCollectProtocolFeeInstruction,
  type ParsedCreateAmmConfigInstruction,
  type ParsedDepositInstruction,
  type ParsedInitializeInstruction,
  type ParsedSwapBaseInputInstruction,
  type ParsedSwapBaseOutputInstruction,
  type ParsedUpdateAmmConfigInstruction,
  type ParsedUpdatePoolStatusInstruction,
  type ParsedWithdrawInstruction,
} from '../instructions';

export const RAYDIUM_CP_SWAP_PROGRAM_ADDRESS =
  'CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C' as Address<'CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C'>;

export enum RaydiumCpSwapAccount {
  AmmConfig,
  ObservationState,
  PoolState,
}

export function identifyRaydiumCpSwapAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): RaydiumCpSwapAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([218, 244, 33, 104, 203, 203, 43, 111])
      ),
      0
    )
  ) {
    return RaydiumCpSwapAccount.AmmConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([122, 174, 197, 53, 129, 9, 165, 132])
      ),
      0
    )
  ) {
    return RaydiumCpSwapAccount.ObservationState;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([247, 237, 227, 245, 215, 195, 222, 70])
      ),
      0
    )
  ) {
    return RaydiumCpSwapAccount.PoolState;
  }
  throw new Error(
    'The provided account could not be identified as a raydiumCpSwap account.'
  );
}

export enum RaydiumCpSwapInstruction {
  CreateAmmConfig,
  UpdateAmmConfig,
  UpdatePoolStatus,
  CollectProtocolFee,
  CollectFundFee,
  Initialize,
  Deposit,
  Withdraw,
  SwapBaseInput,
  SwapBaseOutput,
}

export function identifyRaydiumCpSwapInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): RaydiumCpSwapInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([137, 52, 237, 212, 215, 117, 108, 104])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.CreateAmmConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([49, 60, 174, 136, 154, 28, 116, 200])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.UpdateAmmConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([130, 87, 108, 6, 46, 224, 117, 123])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.UpdatePoolStatus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([136, 136, 252, 221, 194, 66, 126, 89])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.CollectProtocolFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([167, 138, 78, 149, 223, 194, 6, 126])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.CollectFundFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.Initialize;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([242, 35, 198, 137, 82, 225, 242, 182])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.Deposit;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([183, 18, 70, 156, 148, 109, 161, 34])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.Withdraw;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([143, 190, 90, 218, 196, 30, 51, 222])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.SwapBaseInput;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 217, 98, 86, 163, 74, 180, 173])
      ),
      0
    )
  ) {
    return RaydiumCpSwapInstruction.SwapBaseOutput;
  }
  throw new Error(
    'The provided instruction could not be identified as a raydiumCpSwap instruction.'
  );
}

export type ParsedRaydiumCpSwapInstruction<
  TProgram extends string = 'CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C',
> =
  | ({
      instructionType: RaydiumCpSwapInstruction.CreateAmmConfig;
    } & ParsedCreateAmmConfigInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.UpdateAmmConfig;
    } & ParsedUpdateAmmConfigInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.UpdatePoolStatus;
    } & ParsedUpdatePoolStatusInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.CollectProtocolFee;
    } & ParsedCollectProtocolFeeInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.CollectFundFee;
    } & ParsedCollectFundFeeInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.Initialize;
    } & ParsedInitializeInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.Deposit;
    } & ParsedDepositInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.SwapBaseInput;
    } & ParsedSwapBaseInputInstruction<TProgram>)
  | ({
      instructionType: RaydiumCpSwapInstruction.SwapBaseOutput;
    } & ParsedSwapBaseOutputInstruction<TProgram>);
